import BigNumber from 'bignumber.js';

export const RESOURCE_TYPES = {
  QUANTUM_DATA: 'quantumData',
  STELLAR_ESSENCE: 'stellarEssence',
  VOID_FRAGMENTS: 'voidFragments',
  RESONANCE_CRYSTALS: 'resonanceCrystals',
  CHRONOS_PARTICLES: 'chronosParticles',
} as const;

export type ResourceType = (typeof RESOURCE_TYPES)[keyof typeof RESOURCE_TYPES];

export interface ResourceDefinition {
  name: string;
  shortName: string;
  description: string;
  color: string;
  icon: string;
  category: ResourceCategory;
  maxPrecision: number;
}

export type ResourceCategory = 'primary' | 'secondary' | 'special' | 'premium';

export const RESOURCE_DEFINITIONS: Record<ResourceType, ResourceDefinition> = {
  quantumData: {
    name: 'Quantum Data',
    shortName: 'QD',
    description: 'Primary currency generated by quantum communication networks',
    color: '#4F46E5',
    icon: '‚öõÔ∏è',
    category: 'primary',
    maxPrecision: 0,
  },
  stellarEssence: {
    name: 'Stellar Essence',
    shortName: 'SE',
    description: 'Energy harvested from dying stars',
    color: '#F59E0B',
    icon: '‚≠ê',
    category: 'secondary',
    maxPrecision: 2,
  },
  voidFragments: {
    name: 'Void Fragments',
    shortName: 'VF',
    description: 'Matter extracted from dead star systems',
    color: '#7C3AED',
    icon: 'üåå',
    category: 'secondary',
    maxPrecision: 0,
  },
  resonanceCrystals: {
    name: 'Resonance Crystals',
    shortName: 'RC',
    description: 'Crystals formed by geometric beacon patterns',
    color: '#06B6D4',
    icon: 'üíé',
    category: 'special',
    maxPrecision: 0,
  },
  chronosParticles: {
    name: 'Chronos Particles',
    shortName: 'CP',
    description: 'Temporal energy particles earned through gameplay',
    color: '#EF4444',
    icon: '‚ö°',
    category: 'premium',
    maxPrecision: 0,
  },
};

export const RESOURCE_DISPLAY_ORDER: ResourceType[] = [
  'quantumData',
  'stellarEssence',
  'voidFragments',
  'resonanceCrystals',
  'chronosParticles',
];

export class ResourceUtils {
  static formatValue(
    value: BigNumber,
    resourceType: ResourceType,
    compact: boolean = false
  ): string {
    const definition = RESOURCE_DEFINITIONS[resourceType];

    if (compact) {
      return this.formatCompact(value, definition.maxPrecision);
    }

    return this.formatFull(value, definition.maxPrecision);
  }

  static formatCompact(value: BigNumber, precision: number): string {
    const abs = value.abs();

    if (abs.isLessThan(1000)) {
      return value.toFixed(precision);
    } else if (abs.isLessThan(1000000)) {
      return value.dividedBy(1000).toFixed(precision) + 'K';
    } else if (abs.isLessThan(1000000000)) {
      return value.dividedBy(1000000).toFixed(precision) + 'M';
    } else if (abs.isLessThan(1000000000000)) {
      return value.dividedBy(1000000000).toFixed(precision) + 'B';
    } else if (abs.isLessThan(1000000000000000)) {
      return value.dividedBy(1000000000000).toFixed(precision) + 'T';
    } else if (abs.isLessThan(1000000000000000000)) {
      return value.dividedBy(1000000000000000).toFixed(precision) + 'Qa';
    } else {
      return value.dividedBy(1000000000000000000).toFixed(precision) + 'Qi';
    }
  }

  static formatFull(value: BigNumber, precision: number): string {
    return value.toFixed(precision);
  }

  static parseValue(input: string): BigNumber {
    // Remove any formatting characters and parse
    const cleanInput = input.replace(/[,\s]/g, '');

    // Handle suffixes
    const suffixMap: Record<string, BigNumber> = {
      K: new BigNumber(1000),
      M: new BigNumber(1000000),
      B: new BigNumber(1000000000),
      T: new BigNumber(1000000000000),
      Qa: new BigNumber(1000000000000000),
      Qi: new BigNumber(1000000000000000000),
    };

    for (const [suffix, multiplier] of Object.entries(suffixMap)) {
      if (cleanInput.toUpperCase().endsWith(suffix)) {
        const numPart = cleanInput.slice(0, -suffix.length);
        return new BigNumber(numPart).multipliedBy(multiplier);
      }
    }

    return new BigNumber(cleanInput);
  }

  static isValidAmount(input: string): boolean {
    try {
      const value = this.parseValue(input);
      return value.isFinite() && value.isGreaterThanOrEqualTo(0);
    } catch {
      return false;
    }
  }

  static getRarityColor(resourceType: ResourceType): string {
    return RESOURCE_DEFINITIONS[resourceType].color;
  }

  static getResourcesByCategory(category: ResourceCategory): ResourceType[] {
    return RESOURCE_DISPLAY_ORDER.filter(
      type => RESOURCE_DEFINITIONS[type].category === category
    );
  }
}
